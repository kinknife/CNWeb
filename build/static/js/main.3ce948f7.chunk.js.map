{"version":3,"sources":["service/adapter.js","service/connection.js","App.js","serviceWorker.js","index.js"],"names":["window","RTCPeerConnection","webkitRTCPeerConnection","mozRTCPeerConnection","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","URL","mozURL","webkitURL","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","io","require","connectionService","ConnectionService","socket","_this","this","Object","classCallCheck","process","REACT_APP_ENV","on","data","id","cb","type","console","log","handleMessage","name","_this2","emit","roomId","connected","room","_this3","msg","App","props","possibleConstructorReturn","getPrototypeOf","call","state","peers","peerConnections","iceConfig","iceServers","stream","currentId","subcribe","updateApp","bind","getMessagehandler","setState","makeOffer","video","mediaSource","audio","s","e","createRoom","joinRoom","self","pc","addStream","onicecandidate","evnt","sendMsg","by","to","ice","candidate","onaddstream","push","document","createElement","srcObject","height","width","key","autoplay","videosContainer","appendChild","getPeerConnection","createOffer","sdp","setLocalDescription","mandatory","offerToReceiveVideo","offerToReceiveAudio","setRemoteDescription","createAnswer","error","addIceCandidate","_this4","react_default","a","className","onClick","ref","videoContainer","Component","Boolean","location","hostname","match","ReactDOM","render","src_App_0","getElementById","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3ce948f7.chunk.js","sourcesContent":["window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;\r\nwindow.RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.webkitRTCIceCandidate;\r\nwindow.RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;\r\nwindow.URL = window.URL || window.mozURL || window.webkitURL;\r\nwindow.navigator.getUserMedia = window.navigator.getUserMedia || window.navigator.webkitGetUserMedia || window.navigator.mozGetUserMedia;\r\n\r\n","const io = require('socket.io-client');\r\n\r\nclass ConnectionService {\r\n    constructor() {\r\n        let socket\r\n        if(process.env.REACT_APP_ENV !== 'production') {\r\n            socket = io(':4200/');\r\n        } else {\r\n            socket = io('/');\r\n        }\r\n        \r\n        socket.on('connect', () => {\r\n            this.socket = socket;\r\n            this.socket.on('peer.connected', (data) => {\r\n                let id = data.id\r\n                this.cb({type: 'new',id})\r\n            })\r\n            this.socket.on('incomeMsg', (data) => {\r\n                console.log('msg', data)\r\n                this.handleMessage(data)\r\n            })\r\n        });\r\n    }\r\n\r\n    createRoom(name) {\r\n        this.socket.emit('init', {name: name}, (roomId, id) => {\r\n            this.cb({type: 'init', roomId, id, connected: true})\r\n        });\r\n    }\r\n\r\n    joinRoom(room) {\r\n        this.socket.emit('init', {name: room}, (roomId, id) => {\r\n            this.cb({type: 'init', roomId, id, connected: true})\r\n        });\r\n    }\r\n\r\n    sendMsg(msg) {\r\n        this.socket.emit('msg', msg);\r\n    }\r\n\r\n    subcribe(cb) {\r\n        this.cb = cb;\r\n    }\r\n\r\n    getMessagehandler(cb) {\r\n        this.handleMessage = cb;\r\n    }\r\n}\r\n\r\nexport let connectionService = new ConnectionService()","import React, { Component } from 'react';\nimport './App.css';\nimport { connectionService } from './service/connection';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      peers: [],\n      peerConnections: {},\n      iceConfig: { 'iceServers': [] },\n      stream: null,\n      currentId: null,\n      roomId: null,\n      connected: false\n    }\n  }\n\n  componentDidMount() {\n    connectionService.subcribe(this.updateApp.bind(this));\n    connectionService.getMessagehandler(this.handleMessage.bind(this));\n  }\n\n  updateApp(msg) {\n    switch (msg.type) {\n      case 'init':\n        this.setState({\n          roomId: msg.roomId,\n          currentId: msg.id,\n          connected: msg.connected\n        });\n        break;\n      case 'new':\n        this.makeOffer(msg.id);\n        break;\n      default:\n        return;\n    }\n  }\n\n  createRoom(name) {\n    navigator.getUserMedia({\n      video: {\n        mediaSource: 'screen'\n      },\n      audio: true\n    }, (s) => {\n      this.setState({\n        stream: s\n      });\n    }, (e) => {\n      console.log(e);\n    });\n    connectionService.createRoom(name);\n  }\n\n  joinRoom(name) {\n    navigator.getUserMedia({\n      video: true,\n      audio: true\n    }, (s) => {\n      this.setState({\n        stream: s\n      });\n      \n    connectionService.joinRoom(name);\n    }, (e) => {\n      console.log(e);\n    })\n  }\n\n  getPeerConnection(id) {\n    let self = this\n    if (this.state.peerConnections[id]) {\n      return this.state.peerConnections[id];\n    }\n    var pc = new RTCPeerConnection(this.state.iceConfig);\n    this.state.peerConnections[id] = pc;\n    pc.addStream(this.state.stream);\n    pc.onicecandidate = function (evnt) {\n      connectionService.sendMsg({ by: self.state.currentId, to: id, ice: evnt.candidate, type: 'ice' });\n    };\n    pc.onaddstream = function (evnt) {\n      console.log('Received new stream');\n      let peers = self.state.peers\n      peers.push({\n        id: id,\n        stream: evnt.stream\n      })\n      self.setState({\n        peers: peers\n      })\n      \n      let video = document.createElement('video');\n      video.srcObject = evnt.stream;\n      video.height = 270;\n      video.width = 480;\n      video.key = id;\n      video.id = id;\n      video.autoplay = true;\n      self.videosContainer.appendChild(video);\n    };\n    return pc;\n  }\n\n  makeOffer(id) {\n    let pc = this.getPeerConnection(id);\n    let self = this\n    pc.createOffer(function (sdp) {\n      pc.setLocalDescription(sdp);\n      console.log('Creating an offer for', id);\n      connectionService.sendMsg({ by: self.state.currentId, to: id, sdp: sdp, type: 'sdp-offer' });\n    }, function (e) {\n      console.log(e);\n    },\n      { mandatory: { offerToReceiveVideo: true, offerToReceiveAudio: true } });\n  }\n\n  handleMessage(data) {\n    let pc = this.getPeerConnection(data.by);\n    let self = this\n    switch (data.type) {\n      case 'sdp-offer':\n        console.log(data.sdp);\n        pc.setRemoteDescription(new RTCSessionDescription(data.sdp), function () {\n          console.log('Setting remote description by offer');\n          pc.createAnswer(function (sdp) {\n            pc.setLocalDescription(sdp);\n            console.log(sdp)\n            connectionService.sendMsg({ by: self.state.currentId, to: data.by, sdp: sdp, type: 'sdp-answer' });\n          }, function (e) {\n            console.log(e);\n          });\n        }, function (e) {\n          console.log(e);\n        });\n        break;\n      case 'sdp-answer':\n        console.log(data.sdp);\n        pc.setRemoteDescription(new RTCSessionDescription(data.sdp), function () {\n          console.log('Setting remote description by answer');\n        }, function (e) {\n          console.error(e);\n        });\n        break;\n      case 'ice':\n        if (data.ice) {\n          console.log('Adding ice candidates');\n          console.log('join');\n          pc.addIceCandidate(new RTCIceCandidate(data.ice));\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <button onClick={() => { this.createRoom('abc') }}>Create Room</button>\n        <button onClick={() => { this.joinRoom('abc')}}>Join Room</button>\n        <div className=\"videoContainer\" ref={(videoContainer) => {this.videosContainer = videoContainer}}></div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './service/adapter';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}